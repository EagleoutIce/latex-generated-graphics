%% block icon network generator package
%% Florian Sihler, 2021-03-14
\ProvidesPackage{blk-ico-net@block}[2021/03/14 v1.0 blk icon network generator package]

%%% How (TODO: rasterize: TODO: maximum number? TODO: padding [save #pt bigger blocks?])
% NOTE: changed usage... not min; inefficient approach at first ^^
% 1) calculate differences between min and max for both dimens: block@dif@{x,y}
% 2) hold a list for all y with [height-block@min@height] elements:
%       list for all x with [width-block@min@width] elements
%    => Listname is 'matrix'
% 3) update present squares:
%   foreach y:
%     max@[y]@x = min(longest consecutive x in cur:y, block@dif@x)
%     if max@[y]@x<block@min@x: [[Throw; y]]
%   max@y = min(longest consecutive y, block@dif@y)
%   if max@y<block@min@y: [[ERROR]]
%
% update present squares()
%
% ------------------------ on block:
% 4) rand@h = rand(block@y@min, max@y)
% 5) pick random y in list.
%   if any in [y..y+rand@h] not in ylist: [[mod-cycle until it fits]] // has to for y
%   (side:) calculate max@x width possible in [y..y+rand@h] // has to for x
% 6) rand@w = rand(block@x@min, max@x)
% pick random x fitting that width
%
% place block (x, y, rand@w, rand@h)
% kill fields1

% location (lower-left) | color | width | height | special name
\def\binet@draw@single@@block#1#2#3#4#5{% TODO: union node with current path
    \path[binet@block=#2] (#1)++(\binet@inset@x,\binet@inset@y) rectangle ++(#3-\binet@inset@x,#4-\binet@inset@y) node[%
        midway,outer sep=\z@,inner sep=\z@,
        minimum width=#3-\binet@inset@x pt,
        minimum height=#4-\binet@inset@y pt,% TODO: change shading
        binet@node@block=#2%
    ] (#5) {}  coordinate[midway,centered] (binet-block-\arabic{binet@block@count});
}

\def\binet@fronte@draw@block{\@ifnextchar[{\binet@@fronte@draw@block}{\binet@loadBlockColor
\binet@@fronte@draw@block[\binet@blockcolor]}}
\def\binet@@fronte@draw@block[#1](#2,#3,#4,#5){\@ifnextchar[{\binet@@@fronte@draw@block[#1](#2,#3,#4,#5)}{\binet@@@fronte@draw@block[#1](#2,#3,#4,#5)[]}}%
\def\binet@@@fronte@draw@block[#1](#2,#3,#4,#5)[#6]{%
    % assure 1 counter
    \stepcounter{binet@block@count}%
    % compensate inset!
    \binet@draw@single@@block{{#2-\binet@inset@x},{#3-\binet@inset@y}}{#1}{#4+\binet@inset@x}{#5+\binet@inset@y}{#6}%
}

\def\binet@getblock@#1#2{\csname binet@block@#1@#2\endcsname}
\def\binet@getblock#1{\csname binet@block@\arabic{binet@block@count}@#1\endcsname}

\def\binet@setblock#1#2{%
\expandafter\edef\csname binet@block@\arabic{binet@block@count}@#1\endcsname{#2}%
}

\def\binet@setblockrand#1#2#3{\pgfmathrandominteger{\@binet@tmp}{#2}{#3}\setblock{#1}{\@binet@tmp}}
\def\binet@m@max@of@y#1{\ifcsname binet@max@#1@x\endcsname\@nameuse{binet@max@#1@x}\else-1\fi}
\def\binet@get@consecutive@x@{\ifnum\value{binet@a}>\@binet@con@x\relax\edef\@binet@con@x{\arabic{binet@a}}\fi\setcounter{binet@a}{0}}

\def\binet@get@consecutive@x#1{%
% do not run if already known 0
\ifnum\binet@m@max@of@y{\arabic{binet@y}}=0\relax\else
\setcounter{binet@a}{0}% current
\def\@binet@con@x{0}% maximum
\setcounter{binet@x}{#1}% start x
\binet@m@for@x{%
    \binet@if@m@cfree(binet@x,binet@y)%
        {\stepcounter{binet@a}}% free
        {\binet@get@consecutive@x@}%
}\binet@get@consecutive@x@\fi
}

\def\binet@get@consecutive@y@{\ifnum\value{binet@a}>\@binet@con@y\relax\edef\@binet@con@y{\arabic{binet@a}}\fi\setcounter{binet@a}{0}}
\def\binet@get@consecutive@y{%
\setcounter{binet@a}{0}% current
\setcounter{binet@b}{0}% total added
\def\@binet@con@y{0}% maximum
\def\binet@m@ylist{}%
\binet@m@for@y{%
    \ifnum\binet@m@max@of@y{\arabic{binet@y}}=0\relax
        \binet@get@consecutive@y@
    \else
        \stepcounter{binet@a}\stepcounter{binet@b}%
        \listeadd\binet@m@ylist{\arabic{binet@y}}%
    \fi
}\binet@get@consecutive@y@
}

\def\binet@update@present@squares{%
    % TODO: set error flag (if?) in case of insufficient dimensions
    \binet@m@for@y{%
        \binet@get@consecutive@x{0}
        \expandafter\edef\csname binet@max@\arabic{binet@y}@x\endcsname{\@binet@con@x}%
    }
    \binet@get@consecutive@y
    \expandafter\edef\csname binet@max@y\endcsname{\@binet@con@y}%
    \edef\binet@m@ylist@total{\arabic{binet@b}}%
}

\def\binet@block@randxy@picky@first{%
    \pgfmathrandominteger{\binet@rand@y}{0}{\binet@m@ylist@total-\get{h}-1}
    \setcounter{binet@a}{0}% current
    \def\binet@selected@y{-1}%
    \def\do##1{%
        \ifnum\value{binet@a}=\binet@rand@y\relax
            \edef\binet@selected@y{##1}%
        \fi
        \stepcounter{binet@a}%
    }
    \dolistloop{\binet@m@ylist}%
}

% start | height
\def\binet@block@randxy@picky@testfit#1#2{%
    % \binet@m@max@of@y
    \setcounter{binet@y}{#1}%
    \@binet@flag@a@true
    \edef\@binet@y{\the\numexpr#1+#2+1\relax}% +1 as y not <=
    \@whilenum\value{binet@y}<\@binet@y\do{%
        \edef\@binet@tmp{\binet@m@max@of@y{\arabic{binet@y}}}%
        \ifnum\@binet@tmp<1\relax % 0 or invalid
            \@binet@flag@a@false
        \fi
        \stepcounter{binet@y}
    }
}

\def\binet@block@randxy@picky{%
% ylist: \binet@m@ylist (\binet@m@ylist@total)
% cycle up to: as the list is sorted ascending,
% there have to be at least 'h' remaining
\binet@block@randxy@picky@first
\setcounter{binet@a}{\binet@selected@y}%
\ifnum\binet@selected@y<0\relax
    \PackageWarning{blk-ico-net}{first y pick selected '\binet@selected@y' which is registered as a warning. Block will be omitted}
    \@binet@flag@typeset@block@false
\fi
\binet@block@randxy@picky@testfit{\arabic{binet@a}}{\get{h}}
\if@binet@flag@a@\else
    % if this is set binet@a does not suffice
    % so we cycle until it fits or binet@a=\binet@selected@y
    \binet@debug{Original y-selection (\binet@selected@y) failed, reshift}
    \setcounter{binet@b}{0}
    \@whilenum\value{binet@b}<\binet@m@ylist@total\do{%
        \pgfmathparse{int(mod(\arabic{binet@a}+1,\binet@m@ylist@total))}% mod shift 1
        \setcounter{binet@a}{\pgfmathresult}
        \binet@block@randxy@picky@testfit{\arabic{binet@a}}{\get{h}}% free
        \if@binet@flag@a@ % can be placed on this height
            \setcounter{binet@b}{\binet@m@ylist@total}% 'break'
        \fi
        \stepcounter{binet@b}%
    }
\fi
\setblock{y}{\arabic{binet@a}}%
}

\def\binet@get@topline@x@{%
    \ifnum\value{binet@a}<\value{binet@b}\else
        \listeadd\@binet@topline@x{\@binet@curx:\arabic{binet@a}}%
        \stepcounter{binet@c}%
        \edef\@binet@curx{\arabic{binet@x}}
    \fi
    \setcounter{binet@a}{0}%#
}

\def\binet@split@listelem#1:#2;{\edef\binet@cur@xidx{#1}\edef\binet@cur@xlen{#2}}

\def\binet@block@randxy@pickxw@topline{%
    \def\@binet@topline@x{}
    \ifnum\binet@m@max@of@y{\arabic{binet@y}}=0\else
    \setcounter{binet@a}{0}% current
    \setcounter{binet@x}{0}%
    \setcounter{binet@c}{0}% total
    \def\@binet@curx{0}
    \binet@m@for@x{%
        \binet@if@m@cfree(binet@x,binet@y)%
            {\stepcounter{binet@a}}% free
            {\binet@get@topline@x@}%
    }\binet@get@topline@x@\fi
    % select random element and split '@'
    \setcounter{binet@a}{0}% current
    \def\binet@selected@x{}%
    \pgfmathrandominteger{\binet@desired@idx}{0}{\value{binet@c}-1}
    \def\do##1{%
        \ifnum\value{binet@a}=\binet@desired@idx\relax
            \edef\binet@selected@x{##1}%
        \fi
        \stepcounter{binet@a}%
    }
    \dolistloop{\@binet@topline@x}%
    \ifx\binet@selected@x\@empty % if does not catch => save
        \@binet@flag@typeset@block@false
    \else
        \expandafter\binet@split@listelem\binet@selected@x;
    \fi
}

\def\binet@get@xrange@x@{%
    \ifnum\value{binet@a}>\@binet@sub@xlen\relax
        \edef\@binet@sub@xlen{\arabic{binet@a}}%
        \edef\@binet@sub@xidx{\@binet@sub@lastidx}%
    \fi
    \setcounter{binet@a}{0}%
    \edef\@binet@sub@lastidx{\arabic{binet@x}}%
}


\def\binet@block@randxy@pickxw@xrange{%
    \setcounter{binet@x}{\binet@cur@xidx}% current
    \setcounter{binet@a}{0}%
    \def\@binet@sub@lastidx{0}%
    \def\@binet@sub@xidx{0}%
    \def\@binet@sub@xlen{-1}%
    \@whilenum\value{binet@x}<\numexpr\binet@cur@xidx+\binet@cur@xlen+1\relax\do{%
        \binet@if@m@cfree(binet@x,binet@y)%
            {\stepcounter{binet@a}}% free
            {\binet@get@xrange@x@}%
        \stepcounter{binet@x}%
    }\binet@get@xrange@x@
    % intersect [sub:xidx..xidx+xlen] and [cur:xidx..xidx+xlen]
    \edef\binet@cur@xidx@old{\binet@cur@xidx}%
    \ifnum\@binet@sub@xidx>\binet@cur@xidx\relax% low
        \edef\binet@cur@xidx{\@binet@sub@xidx}%
    \fi
    \ifnum\numexpr\@binet@sub@xidx+\@binet@sub@xlen\relax<\numexpr\binet@cur@xidx+\binet@cur@xlen\relax% len
        \pgfmathsetmacro\binet@cur@xlen{int(\@binet@sub@xidx+\@binet@sub@xlen-\binet@cur@xidx)}%
    \fi
}


\def\binet@block@randxy@pickxw{%
% find largest rectangle on y
% trying from block@min@width up to max@[y]@x
\setblockrand{w}{\binet@block@min@width}{min(\binet@block@max@width,\binet@m@max@of@y{\get{y}})}%
\setcounter{binet@b}{\binet@block@min@width}%
\def\binet@effective@w{0}%
\def\binet@effective@x{0}%
\@whilenum\value{binet@b}<\numexpr\get{w}+1\relax\do{%
    \setcounter{binet@y}{\get{y}}%
    % find start in topline => \binet@cur@xidx & \binet@cur@xlen
    \binet@block@randxy@pickxw@topline
    \stepcounter{binet@y}%
    \if@binet@flag@typeset@block@
    \@whilenum\value{binet@y}<\numexpr\get{y}+\get{h}\relax\do{% TODO: maybe +1?
        % search for the largest x-slot in 'xidx..xidx+xlen'
        % if found, it will narrow it down
        \binet@block@randxy@pickxw@xrange
        \stepcounter{binet@y}%
    }%
    \binet@debug{In run for \arabic{binet@b}: [\binet@cur@xidx..+\binet@cur@xlen]}%
    \ifnum\binet@cur@xlen<\binet@effective@w\else
        \ifnum\arabic{binet@b}<\binet@cur@xlen
        \ifnum\binet@cur@xidx<0\else
        \edef\binet@effective@w{\binet@cur@xlen}%
        \edef\binet@effective@x{\binet@cur@xidx}%
        \edef\binet@effective@b{\arabic{binet@b}}%
        \binet@debug{  Updated: [\binet@effective@x..+\binet@effective@w]}%
    \fi\fi\fi
    \fi
    \stepcounter{binet@b}%
}%
\if@binet@flag@typeset@block@
    \ifnum\binet@effective@w<\binet@block@min@width\relax
        \@binet@flag@typeset@block@false
    \else
        \pgfmathparse{int(min(\binet@effective@w,\get{w},\binet@effective@b))}%
        \setblock{w}{\pgfmathresult}%
        \setblockrand{x}{\binet@effective@x}{\binet@effective@x+\binet@effective@w-\get{w}}%
    \fi
\fi
}

% TODO: if fails for current h, try with one h less
\def\binet@block@randxy{
    \setblockrand{h}{\binet@block@min@height}{min(\binet@block@max@height,\binet@max@y)}% 4)
    \binet@block@randxy@picky% 5)
    \binet@block@randxy@pickxw% 6)
}


\def\binet@single@block@specialblock#1#2{
  % block y
  \setcounter{binet@y}{0}
  \@whilenum\value{binet@y}<\binet@getblock@{#1}{h}\do{%
    \setcounter{binet@x}{0}%
    \@whilenum\value{binet@x}<\binet@getblock@{#1}{w}\do{%
        \csname binet@m@#2\endcsname(%
            \the\numexpr\arabic{binet@x}+\binet@getblock@{#1}{x}\relax,%
            \the\numexpr\arabic{binet@y}+\binet@getblock@{#1}{y}\relax)%
        \stepcounter{binet@x}% Block!
    }
    \stepcounter{binet@y}%
  }
}

\def\binet@single@block@block{
  % block y
  \setcounter{binet@y}{0}
  \@whilenum\value{binet@y}<\get{h}\do{%
    \setcounter{binet@x}{0}%
    \@whilenum\value{binet@x}<\get{w}\do{%
        \binet@m@block(%
            \the\numexpr\arabic{binet@x}+\get{x}\relax,%
            \the\numexpr\arabic{binet@y}+\get{y}\relax)%
        \stepcounter{binet@x}% Block!
    }
    \stepcounter{binet@y}%
  }
  \binet@update@present@squares
}

% 4)+
\def\binet@draw@single@block{%
  \@binet@flag@typeset@block@true
  \stepcounter{binet@block@count}
  % \set and allocate dimens
  \binet@loadBlockColor
  \setblock{c}{\binet@blockcolor}
  \binet@block@randxy
  \if@binet@flag@typeset@block@
    \binet@debug{Block[\get{c}](\get{x},\get{y},\get{w},\get{h})}%
    \binet@draw@single@@block{\get{x},\get{y}}{\get{c}}{\get{w}}{\get{h}}{}%
    \binet@single@block@block
  \else
    % free registers
    \addtocounter{binet@block@count}{-1}
  \fi
}
\endinput